# OpenTelemetry Tracing in Go

Traces represent the flow of a request as it moves through different components or services of a system. Traces show the path of a request, the time spent in each service, and any errors encountered along the way, making it easier to pinpoint bottlenecks and root causes of issues.

## 1. APIs

The Tracing API consists of these main components

- **Tracer Provider**: The entry point of the API, holds tracer configuration and provides access to Tracers.
- **Tracer**: Responsible for creating Spans.
- **Span**: The API to trace an operation.
- **SpanContext**: Tepresents the portion of a Span which must be serialized and propagated along side of a distributed context.
- **Sampling**: A process that restricts the amount of spans (dropping span/trace) that are generated by a system.

When a request moves from one service to another, the trace context needs to be carried along. Propagators enable the continuation of a trace across different services or processes in a distributed system.

The Propagators API currently defines one Propagator type: `TextMapPropagator`. This type injects values into and extracts values from carriers as string key/value pairs.

- **Carrier**: A carrier is the medium used by Propagators to read values from and write values to
- **Inject**: The inject operation writes the value into a carrier. For example, into the headers of an HTTP request.
- **Extract**: The extract operation reads the value from an incoming request. For example, from the headers of an HTTP request.
- **Baggage**: A key-value store contains contextual information that resides next to context.

```go
ctx, span := tracer.Start(ctx, "call-payment-gateway",
    trace.WithSpanKind(trace.SpanKindClient),
)
defer span.End()

req, _ := http.NewRequestWithContext(ctx, "POST", "https://payments.example.com/charge", body)

// Inject headers anyway (ignored by external system)
propagator.Inject(ctx, propagation.HeaderCarrier(req.Header))

start := time.Now()
resp, err := http.DefaultClient.Do(req)
elapsed := time.Since(start)

if err != nil {
    span.RecordError(err)
    span.SetStatus(codes.Error, err.Error())
    return
}

span.SetAttributes(
    semconv.HTTPMethodKey.String(req.Method),
    semconv.URLFullKey.String(req.URL.String()),
    semconv.HTTPResponseStatusCodeKey.Int(resp.StatusCode),
    attribute.Int64("http.duration_ms", elapsed.Milliseconds()),
)
```

## 2. SDK Exporter

> [!NOTE]
> The OTel Collector also has exporters â€” but these are collector components. In this setup, the app usually exports data in OTLP format to the collector, and the collector then uses its own exporters to send data to multiple backends.
